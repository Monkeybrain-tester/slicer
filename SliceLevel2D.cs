using Godot;
using System;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// SliceLevel2D: 2D slice world generated by SliceManager.
/// - Polygons2D: cross-section loops in slice space (unscaled).
/// - Segments2D: optional edges for very thin intersections.
/// - PlayerStart2D: starting position in slice space (unscaled).
/// Uses your animated Player (CharacterBody2D with Player.cs) as the 2D avatar.
/// </summary>
public partial class SliceLevel2D : Node2D
{
	// ---------------- Signals ----------------
	[Signal] public delegate void SliceExitEventHandler(Vector2 delta2D);

	// ---------------- Exports ----------------
	[ExportGroup("Scale & Camera")]
	[Export] public float Scale2D = 1.0f;        // pixels per slice unit
	[Export] public float CameraZoom = 1.0f;     // Camera2D zoom

	[ExportGroup("Player")]
	[Export] public PackedScene Player2DScene;   // assign your Player2D.tscn here in the editor

	[ExportGroup("Debug")]
	[Export] public bool EnableDebugCam = true;
	[Export] public bool DrawAabbDebug = true;
	[Export] public bool DrawPolyOutlines = true;
	
	[ExportGroup("Player Spawn Offsets")]
// how many pixels between the player's center and their feet
	[Export] public float CenterToFeetOffsetPx = 12f;

	// ---------------- Data from SliceManager ----------------
	// These are filled in by SliceManager before adding this node to the scene.
	public List<List<Vector2>> Polygons2D = new();   // loops in unscaled slice coords
	public List<Vector2[]> Segments2D = new();       // optional line segments in unscaled coords
	public Vector2 PlayerStart2D = Vector2.Zero;     // unscaled slice coords (u, v)

	// ---------------- Internals ----------------
	private Player _player;      // your animated Player (CharacterBody2D + AnimationTree)
	private Camera2D _cam;
	private Vector2 _startPosPx; // starting position in pixels (for delta2D)
	private bool _debugMode = false;

	public override void _Ready()
	{
		// ---------------- World / geometry ----------------
		var world = GetNodeOrNull<Node2D>("World");
		if (world == null)
		{
			world = new Node2D { Name = "World" };
			AddChild(world);
		}

		// Build visual + collision geometry from Polygons2D & Segments2D
		DrawCrossSectionGeometry(world);
		if (DrawAabbDebug)
			DrawAabbDebugRects(world);

		// ---------------- Player instantiation ----------------
		if (Player2DScene != null)
		{
			_player = Player2DScene.Instantiate<Player>();
			_player.Name = "Player2D";
			AddChild(_player);
		}
		else
		{
			// Try to find an existing Player2D node
			_player = GetNodeOrNull<Player>("Player2D");
			if (_player == null)
			{
				GD.PushError("[SliceLevel2D] No Player2DScene assigned and no 'Player2D' node found. Creating a bare Player.");
				_player = new Player { Name = "Player2D" };
				AddChild(_player);
			}
		}

		// ---------------- Camera setup ----------------
		_cam = _player.GetNodeOrNull<Camera2D>("Camera2D");
		if (_cam == null)
		{
			_cam = new Camera2D { Name = "Camera2D" };
			_player.AddChild(_cam);
		}
		_cam.Zoom = new Vector2(CameraZoom, CameraZoom);
		_cam.PositionSmoothingEnabled = false;
		_cam.MakeCurrent();

		// --------F-------- Spawn position ----------------
		// We trust SliceManager to provide a sensible PlayerStart2D.
		// Convert from slice units to pixels.
		Vector2 spawnPx = PlayerStart2D * Scale2D;

// move the player UP by their center→feet distance
spawnPx.Y -= CenterToFeetOffsetPx;

_player.Position = spawnPx;
_startPosPx = spawnPx;

// Safe reset of motion — only if your Player2D has a Velocity property
if (_player.HasMethod("set_Velocity"))
{
	_player.Set("Velocity", Vector2.Zero);
}

GD.Print($"[Slice2D] Raw spawn px={PlayerStart2D * Scale2D}, adjusted spawn px={spawnPx} " +
		 $"(CenterToFeetOffsetPx={CenterToFeetOffsetPx})");

		GD.Print($"[Slice2D] Raw spawn px={spawnPx} (PlayerStart2D={PlayerStart2D}, Scale2D={Scale2D})");

		if (EnableDebugCam)
			GD.Print("[Slice2D] Press F1 to toggle free-cam mode.");

		SetProcessUnhandledInput(true);
	}

	public override void _UnhandledInput(InputEvent e)
	{
		// Exit back to 3D when slice_exit, ui_cancel, or slice_aim is pressed.
		bool wantExit =
			(InputMap.HasAction("slice_exit") && Input.IsActionJustPressed("slice_exit")) ||
			Input.IsActionJustPressed("ui_cancel") ||
			Input.IsActionJustPressed("slice_aim");

		if (wantExit)
		{
			// delta2D in slice units = (current_px - start_px) / Scale2D
			Vector2 currentPx = _player.GlobalPosition;
			Vector2 delta2D = (currentPx - _startPosPx) / Scale2D;

			GD.Print($"[Slice2D] Exit requested, delta2D={delta2D}");
			EmitSignal(SignalName.SliceExit, delta2D);
			GetViewport().SetInputAsHandled();
			QueueFree();
			return;
		}

		// Debug camera toggle
		if (EnableDebugCam && e is InputEventKey key && key.Pressed && key.Keycode == Key.F1)
			ToggleDebugCamera();
	}

	public override void _PhysicsProcess(double delta)
	{
		// Only handle debug free-cam here; actual movement is handled by Player.cs
		if (_debugMode && _cam != null)
		{
			Vector2 dir = Vector2.Zero;
			if (Input.IsActionPressed("ui_right")) dir.X += 1;
			if (Input.IsActionPressed("ui_left"))  dir.X -= 1;
			if (Input.IsActionPressed("ui_down"))  dir.Y += 1;
			if (Input.IsActionPressed("ui_up"))    dir.Y -= 1;

			if (dir != Vector2.Zero)
			{
				_cam.GlobalPosition += dir.Normalized() * (float)(600 * delta);
			}
		}
	}

	// ------------------------------------------------------------
	// Geometry build & debug draw
	// ------------------------------------------------------------

	private void DrawCrossSectionGeometry(Node2D world)
	{
		// Filled polygons + collision
		foreach (var raw in Polygons2D)
		{
			var poly = SanitizeLoop(raw, 0.0005f);
			if (poly == null || poly.Count < 3 || MathF.Abs(SignedArea(poly)) < 1e-6f)
				continue;

			// Visible fill
			var fill = new Polygon2D
			{
				Polygon = poly.Select(p => p * Scale2D).ToArray(),
				Color = new Color(0.65f, 0.8f, 1f, 0.42f),
				Antialiased = true
			};
			world.AddChild(fill);

			// Collisions via convex decomposition
			AddConvexCollisionFromPolygon(world, poly, Scale2D);

			// Outline for sanity
			if (DrawPolyOutlines)
			{
				var outline = new Line2D
				{
					Width = 2,
					DefaultColor = new Color(0.2f, 0.6f, 1f, 0.9f),
					Closed = true,
					Antialiased = true
				};
				foreach (var p in poly)
					outline.AddPoint(p * Scale2D);
				world.AddChild(outline);
			}
		}

		// Segment lines + collisions (thin slices)
		foreach (var seg in Segments2D)
		{
			if (seg == null || seg.Length != 2) continue;

			var line = new Line2D
			{
				Width = 2f,
				DefaultColor = new Color(0.95f, 0.8f, 0.35f, 1f),
				Antialiased = true
			};
			line.AddPoint(seg[0] * Scale2D);
			line.AddPoint(seg[1] * Scale2D);
			world.AddChild(line);

			var body = new StaticBody2D();
			var cshape = new CollisionShape2D
			{
				Shape = new SegmentShape2D
				{
					A = seg[0] * Scale2D,
					B = seg[1] * Scale2D
				}
			};
			body.AddChild(cshape);
			world.AddChild(body);
		}
	}

	private void DrawAabbDebugRects(Node2D world)
	{
		foreach (var raw in Polygons2D)
		{
			if (raw == null || raw.Count == 0) continue;

			Vector2 min = new(float.MaxValue, float.MaxValue);
			Vector2 max = new(float.MinValue, float.MinValue);
			foreach (var p in raw)
			{
				if (p.X < min.X) min.X = p.X;
				if (p.Y < min.Y) min.Y = p.Y;
				if (p.X > max.X) max.X = p.X;
				if (p.Y > max.Y) max.Y = p.Y;
			}

			var p0 = min * Scale2D;
			var p1 = new Vector2(max.X, min.Y) * Scale2D;
			var p2 = max * Scale2D;
			var p3 = new Vector2(min.X, max.Y) * Scale2D;

			var rect = new Polygon2D
			{
				Polygon = new[] { p0, p1, p2, p3 },
				Color = new Color(1f, 0.2f, 0.2f, 0.15f),
				Antialiased = true
			};
			world.AddChild(rect);

			var outline = new Line2D
			{
				Width = 2,
				DefaultColor = new Color(1f, 0.2f, 0.2f, 0.9f),
				Closed = true
			};
			outline.AddPoint(p0); outline.AddPoint(p1); outline.AddPoint(p2); outline.AddPoint(p3);
			world.AddChild(outline);
		}
	}

	// ------------------------------------------------------------
	// Utility
	// ------------------------------------------------------------

	private static float SignedArea(IReadOnlyList<Vector2> pts)
	{
		double s = 0;
		for (int i = 0; i < pts.Count; i++)
		{
			Vector2 a = pts[i];
			Vector2 b = pts[(i + 1) % pts.Count];
			s += (double)a.X * b.Y - (double)a.Y * b.X;
		}
		return (float)(0.5 * s);
	}

	// Remove near-duplicates, colinears; enforce CCW (positive area).
	private static List<Vector2> SanitizeLoop(List<Vector2> input, float eps)
	{
		if (input == null || input.Count < 3) return input ?? new();

		var tmp = new List<Vector2>(input.Count);
		foreach (var p in input)
		{
			if (tmp.Count == 0 || (p - tmp[^1]).LengthSquared() > eps * eps)
				tmp.Add(p);
		}
		if (tmp.Count > 1 && (tmp[0] - tmp[^1]).LengthSquared() <= eps * eps)
			tmp.RemoveAt(tmp.Count - 1);

		// remove colinears
		if (tmp.Count >= 3)
		{
			var clean = new List<Vector2>(tmp.Count);
			for (int i = 0; i < tmp.Count; i++)
			{
				Vector2 a = tmp[(i - 1 + tmp.Count) % tmp.Count];
				Vector2 b = tmp[i];
				Vector2 c = tmp[(i + 1) % tmp.Count];
				var ab = b - a;
				var bc = c - b;
				float cross = ab.X * bc.Y - ab.Y * bc.X;
				if (MathF.Abs(cross) > eps) clean.Add(b);
			}
			tmp = clean;
		}

		if (tmp.Count >= 3 && SignedArea(tmp) < 0f)
			tmp.Reverse();

		return tmp;
	}

	/// <summary>
	/// Add polygon collisions under 'parent' via convex decomposition (fallback to triangle pieces).
	/// </summary>
	private static void AddConvexCollisionFromPolygon(Node2D parent, List<Vector2> poly, float scale)
	{
		if (poly == null || poly.Count < 3) return;

		var convexes = Geometry2D.DecomposePolygonInConvex(poly.ToArray());
		if (convexes != null && convexes.Count > 0)
		{
			foreach (var cv in convexes)
			{
				if (cv == null || cv.Length < 3) continue;

				var body = new StaticBody2D();
				var col = new CollisionPolygon2D
				{
					BuildMode = CollisionPolygon2D.BuildModeEnum.Solids,
					Polygon = cv.Select(p => p * scale).ToArray()
				};
				body.AddChild(col);
				parent.AddChild(body);
			}
			return;
		}

		// Fallback: triangulate
		var idx = Geometry2D.TriangulatePolygon(poly.ToArray());
		for (int i = 0; i + 2 < idx.Length; i += 3)
		{
			var a = poly[idx[i]];
			var b = poly[idx[i + 1]];
			var c = poly[idx[i + 2]];

			var body = new StaticBody2D();
			var col = new CollisionPolygon2D
			{
				BuildMode = CollisionPolygon2D.BuildModeEnum.Solids,
				Polygon = new[] { a * scale, b * scale, c * scale }
			};
			body.AddChild(col);
			parent.AddChild(body);
		}
	}

	private void ToggleDebugCamera()
	{
		_debugMode = !_debugMode;
		if (_cam != null)
			_cam.GlobalPosition = _player.GlobalPosition;

		GD.Print(_debugMode ? "[Slice2D] Free-cam enabled." : "[Slice2D] Free-cam disabled.");
	}
}
